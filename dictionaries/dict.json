{
    "abstract factory": "provides an interface for creating families of related or dependant objects without specifying their concrete classes.",
    "adapter": "convert the interface of a class into another interface clients expect. adapter elts classes work together that couldn't otherwise.",
    "bridge": "decouple an abstraction from its implementation so that the two can vary independantly.",
    "builder": "separate the construction of a complexe object from its representation so that the same construction process can be used to create different representations",
    "chain of responsibility": "avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. chain the receiving objects and pass the request along teh chian until an object handles it.",
    "command": "encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.",
    "composite": "compose objects into tree structures to represent part-whole herarchies. composites let client treat individual objects and compositions of objects uniformly.",
    "decorator": "attach additional responsiblities to an object dynamically. decorators provide a flexible alternative to subclassing for extending functionality.",
    "facade": "provide a unified interface to a set of interfaces in a subsystem. facade defines a higher-level interafce that makes the sub-system easier to use.",
    "facotry method": "define an interface for creating an object, but let subclasses decide which class to instatiate. factory method lets a class defer instantiation to sub-classes.",
    "flyweight": "use sharing to support large number of fine-grained objects efficiently.",
    "interpreter": "given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.",
    "iterator": "provide a way to access the elements of ana ggregate object sequentially without exposing its underlying representation.",
    "mediator": "define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independantly.",
    "memento": "wihtout violating encapsulation, capture and externalize an objects internal state so that the object can be restored to this state later.",
    "observer": "define a one-to-many dependancy between objects so that when one object changes state, all its dependants are notified and updated automatically.",
    "prototype": "specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.",
    "proxy": "provide a surrogate or place holder for another object to control access to it.",
    "singleton": "ensure a class only has one instance, and provide a global point of access to it.",
    "state": "allow an object to alter its behavior when its internal state changes. the object will appear to change its class.",
    "strategy": "define a family of algorithms, encapsulate each one, and make them interchangable. strategy lets the algorithm vary independantly from clients that use it.",
    "template method": "define the skeleton of an algorithm in an operation, deferring some steps to sub-classes. template method lets subclasses redefine certain steps of an algorithm without changing the algorithm structure.",
    "visitor": "represent an operation to be perforemd on the lemenet of an object structure. visitor lets you define a new oepration without changing the classes of the elements on which it operates."
}